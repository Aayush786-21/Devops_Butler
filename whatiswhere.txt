# DevOps Butler - Codebase Location Guide
# Last Updated: 2025-11-17

## Algorithms Documentation
- **Comprehensive Algorithm List**: See `ALGORITHMS.md` for detailed documentation of all algorithms used in the codebase
- **Categories**: Port finding, retry algorithms, state machines, pattern matching, sorting, search, graph/tree traversal, string processing, polling, circuit breaker, error handling, and more
- **Total Algorithms Documented**: 18+ distinct algorithmic patterns

## SSL/HTTPS Configuration (2025-11-12)
- **Architecture**: All SSL/TLS is handled by Cloudflare at the edge - no SSL certificates needed on origin
- **Solution**: Cloudflare Tunnel connects to origin via HTTP, Cloudflare provides SSL/TLS automatically
- **Location**: `cloudflare_manager.py` - `ensure_project_hostname()` and `_build_service_entry()` functions
- **Changes**:
  - All service URLs are automatically converted from HTTPS to HTTP before configuring Cloudflare Tunnel
  - This ensures Cloudflare connects to origin via HTTP while providing SSL/TLS at the edge for end users
  - **Completely removed**: `ssl_manager.py` deleted - no SSL certificate generation code
  - **Completely removed**: certbot installation from VM setup
  - **Completely removed**: nginx SSL proxy configuration
- **Benefits**:
  - Faster deployments (no certificate generation delays)
  - Simpler setup (no certbot/nginx needed)
  - No SSL errors (Cloudflare handles everything)
  - Still secure (Cloudflare provides SSL certificates automatically)
- **Note**: Users can still access sites via HTTPS - Cloudflare automatically provides SSL certificates and handles encryption

## Recent Updates (Latest Session)

### Fixed Next.js Deployment Logic and Process Management (2025-11-17)
- **Issue Fixed**: 
  1. Next.js applications were incorrectly being served with `python3 -m http.server` instead of `npm start`
  2. Next.js wasn't binding to 0.0.0.0 to be accessible from outside the VM
  3. npm/node processes weren't staying alive when started via deployment system (even though they worked when run manually)
- **Root Cause**: 
  1. The post-build detection logic was checking for build output directories (`build`, `dist`, `out`) but not properly handling Next.js apps. When `build_output == 'next'` (meaning `.next` directory exists), the code was falling through to default static file server logic instead of using the proper Next.js start command.
  2. Next.js was starting with `PORT=XXXX npm start` but wasn't explicitly setting `HOSTNAME=0.0.0.0`, which meant it might only bind to localhost, making it inaccessible from outside the VM.
  3. The deployment system was using `nohup bash -c 'command'` for npm/node commands, which wasn't reliably keeping processes alive or properly setting environment variables. Manual execution worked because it was run directly in an interactive shell.
- **Fix Applied**: 
  1. Added explicit check for Next.js apps before generic build output handling
  2. When Next.js is detected (`is_next == True`), use `HOSTNAME=0.0.0.0 PORT={port} npm start` instead of static file server
  3. Added logic to override incorrect start commands (e.g., if `python3 -m http.server` was incorrectly set for Next.js)
  4. Improved port replacement logic to properly handle `PORT=XXXX` format in commands using regex
  5. **NEW**: Implemented script-based process execution for npm/node/python3 commands (same approach as Python HTTP server)
  6. **NEW**: Script properly extracts and exports environment variables from command string (e.g., `HOSTNAME=0.0.0.0 PORT=6003`)
  7. **NEW**: Script uses `setsid` and `nohup` to ensure processes survive shell exit
  8. **NEW**: Better process detection using `pgrep` to find actual running processes (handles npm spawning node processes)
  9. **NEW**: Improved error reporting - script outputs log file contents when process dies
  10. Next.js requires Node.js server to handle SSR, API routes, and dynamic features - cannot use static file server
  11. `HOSTNAME=0.0.0.0` ensures Next.js binds to all network interfaces, making it accessible via port forwarding
- **Location**: `process_deployment.py` - Post-build detection logic (lines ~1120-1136), port replacement (lines ~1316-1319), and script-based process execution (lines ~1535-1669)
- **Benefits**:
  - Next.js apps now deploy correctly with proper Node.js server
  - Prevents incorrect static file server usage for Next.js
  - Automatically fixes incorrect start commands for Next.js apps
  - Better error messages when fixing incorrect commands
  - Next.js services are now accessible from outside the VM via port forwarding
  - Proper host binding ensures services work correctly with Cloudflare tunnels
  - **Processes now stay alive reliably** - same approach that works for Python HTTP server
  - **Environment variables properly set** - extracted from command and exported in script
  - **Better process detection** - finds actual running processes even when spawned by npm
  - **Improved error diagnostics** - shows log file contents when process fails to start

### Fixed UnboundLocalError for json Module (2025-11-17)
- **Issue Fixed**: `UnboundLocalError: cannot access local variable 'json' where it is not associated with a value` when deploying static sites
- **Root Cause**: A redundant `import json` statement inside the `_run_deployment_attempt` function (line 2103) was shadowing the module-level `import json` (line 12), causing Python to treat `json` as a local variable throughout the entire function. When `json.loads()` was called at line 887 (before the local import), Python raised an UnboundLocalError.
- **Fix Applied**: Removed the redundant `import json` statement inside the function, allowing the module-level import to be used throughout
- **Location**: `process_deployment.py` - Removed redundant import (line 2103)
- **Benefits**:
  - Fixes deployment failures for static sites and Node.js projects
  - Prevents UnboundLocalError when parsing package.json or Docker container status
  - Cleaner code by using module-level imports consistently

### Deployment Logs Shown in Project Logs Page (2025-11-17)
- **Feature Added**: Project Logs page now shows deployment logs (not VM process logs)
- **Implementation**:
  1. **Helper Function**: Created `broadcast_deployment_log()` that broadcasts to both global deployment stream and project-specific logs
  2. **Updated Key Broadcasts**: Updated critical deployment log messages to use the helper function
  3. **Simplified WebSocket**: Changed project logs WebSocket to receive deployment log broadcasts instead of reading VM log file
  4. **Real-time Logs**: Deployment logs are streamed to the Logs page in real-time during deployment
- **Location**: 
  - `process_deployment.py` - Helper function (lines ~35-42) and updated broadcast calls
  - `orchestrator.py` - Project logs WebSocket (lines ~3656-3732)
  - `frontend/src/js/app.js` - Frontend log handling (updated to handle broadcast messages)
- **How It Works**:
  - When deployment runs, `broadcast_deployment_log()` sends logs to both:
    - Global deployment stream (deployment logs page)
    - Project-specific stream (project Logs page)
  - Project Logs WebSocket is registered to receive project-specific broadcasts
  - Logs appear in real-time in the Logs page during deployment
- **Benefits**:
  - Deployment logs are the primary logs shown in the Logs page
  - Real-time streaming of deployment progress
  - Better visibility into deployment process
  - Easier debugging by viewing logs in project context

### Improved Static Site Process Start Verification (2025-11-17)
- **Issue Fixed**: Static sites failing to start - process starts but verification fails
- **Root Cause**: Process verification logic wasn't properly detecting running processes, and pre-start validation was missing
- **Fixes Applied**:
  1. **Pre-Start Validation**: Added verification checks before starting python3 -m http.server:
     - Verify project directory exists
     - Verify Python 3 is available in VM
     - Verify http.server module is available
  2. **Better Error Diagnostics**: Added direct command testing when log file is missing to capture actual errors
  3. **Improved Logging**: Better error messages and diagnostic output to help debug process start issues
- **Location**: `process_deployment.py` - Process start and verification (lines ~1466-1578)
- **Benefits**:
  - Catches configuration issues before attempting to start process
  - Better error messages when process fails to start
  - More reliable process verification
  - Easier debugging of process start failures

### Fixed Docker Detection Logic and Auto-Fix for Static Sites (2025-11-17)
- **Issue Fixed**: 
  1. Deployment form incorrectly pre-filling "docker compose up -d" for projects without Docker files
  2. Static sites failing to start because incorrect Docker commands were being executed
- **Root Cause**: 
  1. Docker detection logic was not robustly checking if Docker files actually exist before suggesting Docker commands
  2. Process deployment was executing Docker commands even when no Docker files existed, causing failures
- **Fixes Applied**:
  1. **Improved File Existence Checks**: Changed from simple string matching to explicit file existence checks using `[ -f ... ]` tests
  2. **Better Output Parsing**: Changed to check for exact "EXISTS" string match instead of substring matching
  3. **Added Logging**: Added debug logging to track Docker file detection results
  4. **Explicit Checks**: Now explicitly checks both docker-compose.yml/yaml and Dockerfile separately with proper error handling
  5. **Skip Docker When No Files**: Added explicit check to skip Docker detection when Docker is available but no Docker files exist
  6. **Auto-Fix Before Start**: Added pre-start validation that detects incorrect Docker commands and automatically replaces them with correct static HTTP server commands for static sites
  7. **Improved Docker Check in Process Deployment**: Fixed the Docker file check in `process_deployment.py` to use the same robust logic as project analyzer
- **Location**: 
  - `project_analyzer.py` - `analyze_project_simple()` function (lines ~572-627)
  - `process_deployment.py` - Pre-start validation (lines ~1415-1460)
- **Benefits**:
  - Prevents incorrect Docker command suggestions for non-Docker projects
  - More accurate project type detection
  - Better logging for debugging detection issues
  - Handles edge cases where Docker is available but project doesn't use it
  - Auto-fixes incorrect commands before deployment fails
  - Prevents static sites from failing due to incorrect Docker commands
- **Note**: If a project already has incorrect Docker commands saved in the database, the system will now automatically detect and fix them when deploying, replacing Docker commands with appropriate static HTTP server commands for static sites

### Improved VM Process Start and Verification (2025-11-17)
- **Issue Fixed**: VM processes not staying alive or not being properly verified
- **Root Cause**: Process start command wasn't ensuring process stays alive, and verification was insufficient
- **Fixes Applied**:
  1. **Improved Start Command**: Changed from `nohup sh -c` to `nohup bash -c` for better shell compatibility
  2. **Better Process Verification**: Added log file existence check before port verification
  3. **Retry Logic**: Added retry mechanism (3 attempts with increasing wait times: 2s, 4s, 6s) if port not listening
  4. **HTTP Health Check**: Added HTTP accessibility verification inside VM using curl
  5. **Final HTTP Check**: Added final HTTP health check after process is confirmed running
  6. **Increased Wait Time**: Changed initial wait from 2s to 3s for process to fully start
- **Verification Flow**:
  1. Check log file exists (ensures command executed)
  2. Check port is listening (primary verification)
  3. Extract PID from port (multiple methods: lsof, ss, netstat, pgrep)
  4. If port not listening, retry up to 3 times with increasing wait intervals
  5. During retry, perform HTTP check inside VM to verify service responds
  6. Final HTTP health check after process confirmed running
- **Location**: `process_deployment.py` - Process start and verification logic (lines ~1245-1679)
- **Benefits**:
  - Processes stay alive reliably (better shell command)
  - More robust verification (multiple checks)
  - Automatic retry if process starts slowly
  - HTTP verification ensures service is actually accessible
  - Better error messages and logging

## Recent Updates (Previous Session)

### New Deploy Page (Simplified) (2025-11-13)
- **Feature**: Added a new simplified "+ New Deploy" page with clean UI
- **Location**: 
  - Frontend HTML: `frontend/src/index.html` and `static/index.html` - new `page-new-deploy` section
  - Frontend CSS: `frontend/src/css/styles.css` - `.new-deploy-*` styles
  - Frontend JS: `frontend/src/js/app.js` - `showNewDeployPage()`, `toggleSplitMode()`, `handleContinueDeploy()` functions
- **Functionality**:
  1. Shows "Let's build something new" heading
  2. Single repository input with chain link icon (default view)
  3. "Split" button toggles to show frontend/backend repository inputs
  4. "Continue" button validates input and navigates to full deploy page with pre-filled values
  5. The split mode uses existing split deployment functionality (treats frontend+backend as single project)
- **User Flow**:
  - Click "+ New Deploy" → See simplified page → Enter repo URL(s) → Click "Continue" → Full deploy page with values pre-filled
  - Click "Split" → Shows frontend/backend inputs → Enter both URLs → Click "Continue" → Deploys as split project
- **Note**: This is a separate page from the existing deploy page - the old deploy page remains unchanged

### Project-Specific Logs (2025-11-13)
- **Change**: Removed global "Logs" page, moved logs to be project-specific
- **Rationale**: Each project should have its own logs view, not a global one mixing all projects
- **Implementation**:
  1. Removed global "Logs" nav item from main sidebar
  2. Removed global logs page HTML (`page-logs`)
  3. Removed global logs WebSocket endpoint (`/ws/logs`)
  4. Removed global logs functions (`loadLogs`, `connectLogsWebSocket`, `appendLog`, `setupLogsButtons`)
  5. Added "Logs" nav item to project sidebar (appears when a project is selected)
  6. Updated `showProjectContent()` to handle 'logs' case
  7. Updated project logs WebSocket to read from VM log file (`/tmp/project-{project_id}.log`)
  8. Updated `get_project_logs()` endpoint to read from VM instead of process manager
- **User Experience**:
  - Select a project → See project sidebar → Click "Logs" → View that project's logs
  - Each project shows only its own logs (from `/tmp/project-{project_id}.log` in VM)
  - Real-time streaming via WebSocket (`/ws/project/{project_id}/logs`)
- **Location**: 
  - Frontend: `frontend/src/index.html` (removed global logs nav and page), `frontend/src/js/app.js` (removed global functions, added logs to project sidebar)
  - Backend: `orchestrator.py` (removed `/ws/logs`, updated `/ws/project/{project_id}/logs` and `/projects/{project_id}/logs`)
- **Benefits**:
  - Better organization (logs are project-specific)
  - Cleaner UI (no global logs page)
  - More intuitive (logs are where you expect them - in the project)
  - Works with VM-based deployments (reads from VM log files)

### Domain Configuration Health Check (2025-11-13)
- **Issue Fixed**: 502 Bad Gateway errors when accessing domain before service is running
- **Root Cause**: Domain configuration was setting Cloudflare tunnel to point to `localhost:port` without any verification
- **Fix**: Added optional health check that logs warnings but does NOT block domain configuration
- **How It Works**:
  1. When user saves domain, backend determines service URL (`http://localhost:{host_port}`)
  2. **NEW**: Performs optional HTTP health check on service URL (3 second timeout) - **informational only**
  3. If service is accessible (returns HTTP status < 400): Logs info message
  4. If service is not accessible: Logs warning but **still configures domain** (allows users to configure domain first, then start service)
  5. Domain is always configured regardless of service status
  6. Domain will work once the service is started
- **User Workflow** (Correct Flow):
  1. User imports project
  2. User configures domain (works even if service not running) ✅
  3. User deploys/starts service
  4. Domain works immediately once service is running ✅
- **Error Handling**:
  - Service accessible: Logs info message
  - Service returning 4xx/5xx status codes: Logs warning but proceeds
  - Service not accessible: Logs warning but proceeds (domain configured anyway)
  - Unexpected errors: Logs warning but proceeds (non-fatal)
- **Key Principle**: Domain configuration is independent of service status - users can configure domain first, then start service
- **Location**: `orchestrator.py` - `configure_project_domain()` endpoint (line ~2193)
- **Benefits**:
  - Users can configure domain before deploying (flexible workflow)
  - Domain works immediately once service is started
  - Health check provides useful information without blocking configuration
  - No fatal errors - domain always configures successfully

### Auto-Restart for Stopped Services (2025-11-13)
- **Issue Fixed**: Imported projects showing as "running" but service not actually running
- **Root Cause**: Services can crash or stop, but database still shows "running" status
- **Fix**: Added auto-restart logic that detects stopped services and restarts them automatically
- **How It Works**:
  1. When checking deployment status, verifies service is actually accessible via HTTP
  2. If deployment is marked "running" but HTTP check fails, automatically restarts the service
  3. Updates database with new PID after successful restart
  4. Only restarts VM-based deployments (not container deployments)
- **Location**: `orchestrator.py` - `/deployments` endpoint (line ~1851)
- **Restart Endpoint**: Fixed `/projects/{project_id}/restart` to handle VM deployments (line ~2354)
- **Benefits**:
  - Services automatically recover from crashes
  - No manual intervention needed
  - Status check is accurate (only shows "running" if actually accessible)
  - Works for all VM-based deployments

### GitHub PAT Support for Rate Limit Bypass (2025-11-13)
- **Issue Fixed**: GitHub API rate limit exceeded errors when browsing repositories
- **Root Cause**: Unauthenticated GitHub API calls have very low rate limits (60 requests/hour)
- **Fix**: Added support for GitHub Personal Access Token (PAT) as fallback authentication
- **How It Works**:
  1. **Priority 1**: Uses user's personal GitHub token (if authenticated via OAuth)
  2. **Priority 2**: Falls back to global PAT from environment variable (`GITHUB_PAT` or `GITHUB_TOKEN`)
- **Setup**: Add your GitHub PAT to `.env` file:
  ```
  GITHUB_PAT=ghp_your_personal_access_token_here
  ```
  Or use `GITHUB_TOKEN` (both are supported)
- **Location**: `repository_tree_api.py` - `get_github_token()` helper function
- **Endpoints Updated**:
  - `/api/repository/{owner}/{repo}/contents` - Browse repository files
  - `/api/repository/{owner}/{repo}/contents/{path}` - Get file content
  - `/api/repositories/{username}` - List user repositories
- **Benefits**:
  - Bypasses rate limits (5000 requests/hour with PAT vs 60 without)
  - Works for all users (even unauthenticated ones)
  - No code changes needed - just add PAT to environment variable
  - Secure (PAT stored in environment, not in code)

### Robust Process Cleanup and Redeployment (2025-11-13)
- **Issue Fixed**: Redeployments were failing because old processes weren't stopped before starting new ones
- **Root Cause**: Port conflicts and zombie processes from previous deployments
- **Fix**: Added targeted process cleanup that ONLY stops the specific project being redeployed
- **Key Principle**: Only stop THIS project's process, NOT other projects (users can have 10+ projects running)
- **Cleanup Methods** (executed in order, all specific to the deployment being redeployed):
  1. **Kill by PID**: Stops process using stored PID from THIS deployment's database record
  2. **Kill by OLD Port**: Finds and kills process using THIS deployment's OLD port (not the new port)
     - Uses `existing_deployment.host_port` or `existing_deployment.port` (the OLD port)
     - CRITICAL: Never kills processes on the NEW port (that might be used by another project)
  3. **Kill by Log File**: Kills processes associated with THIS deployment's log file (`/tmp/project-{deployment_id}.log`)
  4. **Port Verification**: Verifies the NEW port is free before starting (should be free due to port assignment)
- **Safety Features**:
  - Only targets the specific `deployment_id` being redeployed
  - Uses OLD port from database (not the newly assigned port)
  - Never affects other projects running on different ports
  - Works correctly even if port doesn't change (same port redeployment)
- **Error Handling**: 
  - Continues deployment even if cleanup has warnings (non-fatal)
  - Logs all cleanup actions for debugging
  - Only fails if critical errors occur
- **Location**: `process_deployment.py` - Before process start (line ~1127)
- **Benefits**:
  - Clean redeployments without port conflicts
  - No zombie processes from previous deployments
  - Safe for multi-project environments (doesn't affect other projects)
  - Robust error handling and recovery
  - Automatic port cleanup (only for the project being redeployed)

### Robust Service URL Configuration (2025-11-13)
- **Issue Fixed**: Domain configuration was using VM IP (`http://192.168.x.x:port`) instead of `localhost:port`, causing 502 errors
- **Root Cause**: Fallback logic prioritized VM IP over `localhost:port`, but Cloudflare tunnel runs on Mac and can ONLY access localhost
- **Fix**: Reordered service URL determination logic to ALWAYS prefer `localhost` over VM IP
- **Priority Order**:
  1. `localhost:{host_port}` (if host_port is set)
  2. `localhost:{port}` (if port is set - OrbStack auto-forwards)
  3. `http://{vm_ip}:{port}` (last resort only, with warning logged)
- **Error Handling**: Added validation to ensure service URL is always valid before configuring Cloudflare
- **Location**: `orchestrator.py` - Three endpoints updated:
  - `configure_project_domain()` (line ~2065)
  - Deployment update logic (line ~1108)
  - `fix_cloudflare_tunnel()` (line ~2150)
- **Benefits**:
  - Eliminates 502 errors from incorrect service URLs
  - Always uses localhost (Cloudflare tunnel requirement)
  - Better error messages when configuration fails
  - Logs warnings when VM IP is used (should never happen)

### Host Port Forwarding Architecture (2025-11-13)
- **Change**: Migrated from VM IP-based routing to host port forwarding
- **Architecture**: 
  - Cloudflare tunnel runs on Mac host
  - Each deployment gets a unique host port (6001, 6002, etc.)
  - OrbStack forwards host port → VM port automatically
  - Cloudflare tunnel connects to `localhost:<host_port>` on Mac
- **Benefits**:
  - No need to track VM IPs (if VM IP changes, port forwarding still works)
  - Stable host ports per project
  - Simpler configuration (Cloudflare always uses localhost)
- **Implementation**:
  - `vm_manager.py` - `find_free_host_port()` and `setup_port_forwarding()` functions
  - `process_deployment.py` - Automatically finds free host port and sets up forwarding
  - `orchestrator.py` - All Cloudflare configs use `localhost:<host_port>`
- **Port Range**: 6001-6999 (automatically finds free port)
- **Location**: `vm_manager.py` (lines 574-618), `process_deployment.py` (lines 1557-1580), `orchestrator.py` (multiple endpoints)

### Domain Pattern Change - Single-Level Subdomain (2025-11-13)
- **Change**: Updated domain pattern from `project-name.butler.aayush786.xyz` to `project-name.aayush786.xyz`
- **Reason**: Single-level subdomains are covered by `*.aayush786.xyz` wildcard certificate, eliminating SSL errors
- **Location**: 
  - `process_deployment.py` - Default domain generation (line 1507)
  - `orchestrator.py` - `_default_project_domain()` and `_get_butler_domain()` functions (lines 116-118, 133)
  - `login.py` - Comment update (line 42)
  - `frontend/src/js/app.js` - Domain display in UI (lines 3048, 3156)
- **Environment Variable**: `BUTLER_DOMAIN` now defaults to `aayush786.xyz` (was `butler.aayush786.xyz`)
- **Database**: Updated existing deployment records to use new domain pattern
- **Cloudflare**: Removed old tunnel entries and configured new domain pattern in Cloudflare tunnel
- **Impact**: All new deployments will use the single-level subdomain pattern automatically
- **Verification**: All configurations verified - .env, database, Cloudflare tunnel, and frontend all updated

### Simple and Robust Project Analyzer (Replaced AI-based Analysis)
- **Major Change**: Replaced complex AI-based analysis with simple, robust file-based detection
- **Location**: `project_analyzer.py` - Simple file detection to identify project types
- **Why**: Simpler, faster, more reliable - no AI dependencies, immediate results
- **Detection Priority**:
  1. **Static HTML sites** (index.html or multiple .html files) → `build_command=None`, `start_command=python3 -m http.server 8080`, `port=8080`
  2. **Python projects** (requirements.txt + Python entry points) → Detects Django, Flask, FastAPI, or generic Python
  3. **JavaScript/Node projects** (package.json) → Detects React, Next.js, Vue.js, Express.js, NestJS, or generic Node.js
  4. **Docker projects** (Dockerfile) → Detected but not supported (process-based deployment only)
  5. **Unknown** → Safe defaults
- **Enhanced Python Detection (2025-11-13)**:
  - **Flexible Entry Point Detection**: Now detects ANY .py file in root directory, not just standard names (app.py, main.py, etc.)
  - **AI-Powered Analysis**: 
    - Uses Google Gemini AI to intelligently analyze project structure
    - Reads README.md FIRST (highest priority) for deployment instructions
    - Reads package.json, requirements.txt, config files, and project structure
    - All detection logic is in the AI prompt - no hardcoded if-else chains
    - AI makes intelligent decisions based on all project files
    - Falls back to file-based detection if AI is unavailable
  - **Handles Non-Standard Files**: Can detect and deploy applications with custom entry points like `bot.py`, `barsha.py`, `turuturu.py`, etc.
  - **Smart Flask Detection**: 
    - Searches for Flask imports in Python files to find the actual Flask app
    - Automatically sets `FLASK_APP` environment variable when Flask is detected
    - Falls back to direct Python execution if `flask run` fails
  - **Framework-Specific Detection** (AI-powered, all logic in prompt):
    - Django: Detects `manage.py` → `python3 manage.py runserver 0.0.0.0:8000`
    - Flask: Detects Flask in requirements.txt + searches for Flask app in .py files → `FLASK_APP={file} flask run --host 0.0.0.0 --port 5000 || python3 {file}`
    - FastAPI: Detects FastAPI/uvicorn in requirements.txt → `uvicorn {module}:app --host 0.0.0.0 --port 8000`
    - Generic Python: Uses detected entry file → `python3 {entry_file}`
    - React: 
      - Intelligently parses package.json as JSON to read scripts and dependencies
      - Detects React, Vite, Create React App from dependencies
      - Checks for vite.config.js to determine build output directory
      - Checks for existing build/ or dist/ folders from previous builds
      - Builds with `npm install && npm run build`
      - **Post-build verification**: After build completes, checks what was actually built
      - Automatically adjusts start command to serve from build/ or dist/ folder
      - Serves static files using `python3 -m http.server --directory build` (NOT `npm start` which is dev mode)
      - If build creates build/ or dist/ folder, automatically updates start command to serve from there
    - Vue.js: Detects Vue → Builds → Serves from `dist/` folder
    - Next.js: Detects Next.js → Builds → Uses `npm start` (Next.js handles production serving)
- **Framework Detection**:
  - **Static**: Detects pure HTML sites (no build needed)
  - **Python**: Detects Django (manage.py), Flask (requirements.txt contains Flask), FastAPI (requirements.txt contains fastapi/uvicorn), or generic Python
  - **JavaScript**: Detects Next.js, React, Vue.js, Express.js, NestJS from package.json dependencies
- **Integration**: 
  - Runs **synchronously** during import (not background) - user gets immediate feedback
  - Updates deployment record immediately with detected build_command, start_command, and port
  - Broadcasts analysis results in real-time via WebSocket
- **Benefits**:
  - **Simple**: No AI API calls, no complex prompts, no JSON parsing
  - **Fast**: Immediate results, no waiting for AI responses
  - **Robust**: File-based detection is reliable and predictable
  - **Effective**: Accurately detects common project types (Static, Python, JavaScript)
- **Error Handling**: Analysis failures don't block import - gracefully handles errors with safe defaults
- **Location**: `project_analyzer.py`, `orchestrator.py` (import endpoint at `/api/import`)
- **Removed**: Complex AI/Gemini integration (no longer needed)

### MAJOR ARCHITECTURE CHANGE - VM-Based Deployment with OrbStack
- **New Deployment Model**: Each user gets an isolated OrbStack VM for deployments
- **Rationale**: Prevents excessive file creation on Mac host, provides isolation between users, cleaner file system
- **VM Management**: `vm_manager.py` - Creates and manages OrbStack VMs per user
- **VM Creation**: Automatically created when user registers (asynchronous, non-blocking)
- **VM Setup**: VMs are Ubuntu-based and automatically configured with dependencies (git, nodejs, python3, npm, etc.)
- **Deployment Flow**: 
  1. User registers → VM created automatically (`butler-user-{user_id}`)
  2. User imports repo → Repo cloned inside VM (`/home/{username}/projects/{deployment_id}`) - dynamically detects VM username
  3. Build command executed inside VM (if needed)
  4. Start command executed inside VM (background process with nohup)
  5. Domain configured: `project-name.aayush786.xyz` → `localhost:{port}` (via Cloudflare tunnel)
- **Project Directory Format**: `/home/{username}/projects/{deployment_id}` (dynamically detected username, e.g., `/home/ubuntu/projects/1` or `/home/aayush/projects/1`)
- **Migration**: Old deployments with `/projects/{deployment_id}` are automatically migrated to `/home/{username}/projects/{deployment_id}` during deployment
- **Database Changes**: Added VM fields to `Deployment` model:
  - `vm_name` (TEXT) - OrbStack VM name (e.g., "butler-user-1")
  - `vm_ip` (TEXT) - VM IP address
  - `host_port` (INTEGER) - Host port (forwarded from VM)
- **VM Lifecycle**: VMs are created on user registration, persist across deployments, and can be deleted when user is deleted
- **Domain Format**: `project-name.aayush786.xyz` (with dot, not hyphen)
- **Cloudflare Integration**: Domains automatically configured in Cloudflare tunnel after deployment
- **Location**: `vm_manager.py`, `auth.py` (user registration), `orchestrator.py` (registration endpoint), `process_deployment.py` (VM-based deployment), `login.py` (Deployment model), `database.py` (migrations)

### MAJOR ARCHITECTURE CHANGE - Process-Based Deployment (Like Vercel/Netlify)
- **New Deployment Model**: Replaced Docker containerization with direct process execution
- **Rationale**: Simpler UX, faster deployments, more flexible (users specify commands), feels like Vercel/Netlify
- **Note**: This is now combined with VM-based deployment - processes run inside user VMs, not on host Mac
- **Removed Files**:
  - `docker_build.py` - Docker image building (removed)
  - `docker_run.py` - Docker container management (removed)
  - `dockerfile_templates/` - Dockerfile templates directory (removed)
- **New Files**:
  - `vm_manager.py` - Manages OrbStack VMs for user isolation (creates, starts, stops, executes commands in VMs)
  - `process_manager.py` - Manages processes (start, stop, restart, logs, health checks) - NOW RUNS INSIDE VMs
  - `process_deployment.py` - Process-based deployment handler (replaces Docker deployment) - NOW DEPLOYS TO VMs
- **Database Changes**: Added fields to `Deployment` model:
  - `build_command` (TEXT) - Build command (e.g., "npm install && npm run build")
  - `start_command` (TEXT) - Start command (e.g., "npm run start")
  - `port` (INTEGER) - Port number
  - `process_pid` (INTEGER) - Process ID for tracking
  - `project_dir` (TEXT) - Persistent project directory (projects stored in `projects/` folder)
- **Auto-Detection**: Automatically detects build/start commands from package.json, requirements.txt, etc.
- **Process Management**: Uses subprocess.Popen for direct process execution, no Docker needed
- **Logs**: Real-time log streaming from process stdout/stderr
- **Health Checks**: Process status and port accessibility monitoring
- **UI Updates**:
  - Added optional build/start command and port fields in deploy form (Advanced Options)
  - Updated project cards to show port and PID instead of container uptime/image
  - Updated configuration page to show process fields (port, PID, start command, build command)
  - Updated component cards to show process info
  - Removed all Docker/container references from UI
- **Requirements**: Removed `docker==7.0.0` dependency (no longer needed)
- **Location**: `process_manager.py`, `process_deployment.py`, `login.py` (Deployment model), `database.py` (migrations), `orchestrator.py` (updated endpoints), `frontend/src/` (UI updates)
- **Branch**: `no_containerize` - All changes pushed to this branch

## Previous Updates

### Bug Fixes - Port Conflict Resolution
- **Auto Port Cleanup**: `orchestrator.py` now automatically kills processes on port 8000 before starting
- **Problem**: "Address already in use" error occurred when orphaned uvicorn processes weren't cleaned up
- **Solution**: Added `free_port_8000()` function that runs before server startup to check and kill any processes using port 8000
- **Location**: Lines 1689-1718 in `orchestrator.py`

### Bug Fixes - JSON Parsing Error on Login & 500 Error Handling
- **Fixed JSON Parse Error**: `frontend/src/js/auth.js` now handles non-JSON responses gracefully
- **Problem**: "JSON.parse: unexpected character" error when server returned HTML error pages or invalid responses
- **Solution**: Changed from `response.json()` to `response.text()` first, then try parsing JSON with proper error handling
- **Location**: Login function (lines 116-131) and Register function (lines 215-230) in `auth.js`
- **Note**: Frontend must be rebuilt after this change (`npm run build` in frontend directory)

### Bug Fixes - Global Exception Handler & Bcrypt Error Handling
- **Global Exception Handler**: Added `@app.exception_handler(Exception)` in `orchestrator.py` to ensure all errors return JSON
- **Problem**: Unhandled exceptions returned plain text "Internal Server Error" instead of JSON
- **Solution**: Global handler catches all exceptions and returns proper JSON error responses
- **Location**: Lines 169-193 in `orchestrator.py`
- **Bcrypt Error Handling**: Added try-catch blocks in `auth.py` for password verification to handle bcrypt compatibility issues
- **Location**: `verify_password()` and `authenticate_user()` functions in `auth.py`

### Environment Configuration
- **Google AI API Key**: Added `GOOGLE_AI_API_KEY` to `.env` file for Google AI integration

### New Features - Environment Variable Detection
- **Smart Detection**: Automatically detects env vars from repository code before deployment
- **Detection Dialog**: Shows detected vars with 3 options: Import All, Add Manually, No Skip
- **Pattern Matching**: Detects vars from process.env, os.getenv, os.environ, etc.
- **Built-in Filter**: Ignores common system vars (NODE_ENV, PATH, HOME, etc.)
- **Auto-Import**: One-click import of all detected vars with empty values
- **Multi-Repo Support**: Scans both frontend and backend repos for vars
- **Config File Priority**: Prioritizes vars found in next.config, .env.example, etc.
- **Node.js Deployment Fix**: Deployment now warns about missing env vars instead of failing

### UI/UX Improvements
- **Settings Page Redesign**: Modern layout with profile picture, password modal, toast notifications
- **Avatar Storage**: Moved from `static/avatars/` to `uploads/avatars/` to prevent deletion on frontend rebuild
- **Logo Update**: Replaced "DB" text with devops.png image in all sidebars
- **Terminology Update**: All user-facing "split repository" → "multi-repository" (internal code unchanged for compatibility)
- **Env Var Drag & Drop**: Environment Variables page now has a drag-and-drop `.env` upload drop zone that automatically imports dropped files (`frontend/src/index.html`, `frontend/src/js/app.js`, `frontend/src/css/styles.css`)
- **Log Stream Parsing**: WebSocket log clients now auto-detect plain-text messages, avoiding JSON parse errors during deployments (`frontend/src/js/app.js`)
- **Env Var Timestamp Display**: Environment Variables list now shows precise timestamps formatted in Kathmandu time, and log timestamps follow the same zone (`frontend/src/js/app.js`)
- **Per-Project Subdomains**: Projects can claim Cloudflare-hosted subdomains like `project-butler.example.com` (single label before base domain); backend syncs tunnel ingress/DNS, prevents cross-account reuse, and frontend manages status with a single save button & Open Site now prefers the custom host (`cloudflare_manager.py`, `orchestrator.py`, `frontend/src/js/app.js`, `frontend/src/css/styles.css`). Users can register a domain before the first deploy (status `pending`), and the deploy button now blocks only when no domain is configured, guiding them via a modal.

### Bug Fixes
- **Split Repo Deletion**: Fixed cascade deletion of child components when deleting parent
- **Avatar Disappearance**: Fixed avatars being deleted when running npm build (moved to uploads/)
- **2FA Removal**: Removed non-functional 2FA section from Settings page
- **Node.js Deployment**: Fixed deployment failing when env vars are missing (now continues with warning)

### Other New Features
- **Password Modal**: Added change password modal with real-time strength indicator
- **Toast Notifications**: Added success/error/info toast system for user feedback
- **Avatar Management**: Profile picture upload, display, removal with persistent storage

### Environment Variables Simplification
- **Removed Project Selector**: No more dropdown to switch between projects
- **Current Project Only**: Env vars page only shows/manages vars for currently selected project
- **No Global Variables**: Removed "All Projects (Global)" option - all vars are project-specific
- **Clearer UX**: Users must select a project from Projects page to manage its env vars

## Frontend Files

### Main Application
- **Main HTML**: `frontend/src/index.html` - Single page application with all pages
- **Main JavaScript**: `frontend/src/js/app.js` - Client-side routing, project management, API calls
- **Main Styles**: `frontend/src/css/styles.css` - All CSS styles including modals, buttons, cards
- **Built Output**: `static/` directory - Production build output served by FastAPI

### Key Frontend Functions
- **Delete Project**: `frontend/src/js/app.js` - `deleteProject(projectId)` function at line ~128
- **Delete Confirmation Dialog**: `frontend/src/js/app.js` - `showDeleteConfirmation(projectName)` at line ~182 (simple minimal dialog)
- **Multi-Repository Import Dialog**: `frontend/src/js/app.js` - `showSplitImportDialog()` at line ~2967
  - **User-Facing Text**: "Import as Multi-Repository?"
  - **Internal**: Still uses split-* CSS classes and split API calls
- **Project Name Modal**: `frontend/src/js/app.js` - `openProjectNameModal()` at line ~1519
- **Project Logs Modal**: `frontend/src/js/app.js` - `showProjectLogsModal()` at line ~889
- **Project Components Display**: `frontend/src/js/app.js` - `loadAndDisplayProjectComponents()` at line ~1599
  - **Location**: ALWAYS displayed on Deploy page ONLY (never on Configuration page)
  - **Visibility**: Only shown when BOTH frontend AND backend are deployed (not just imported) AND deploy page is visible
  - **Animation**: Slides in with fade, pushes deploy card down smoothly
  - **CSS**: `.project-components-card` with `.components-visible` class (line ~2480)
  - **Auto-refresh**: Refreshes after successful deployment for multi-repos
  - **Key Fix**: Function checks `deployPage.style.display !== 'none'` before showing components section
  - **Configuration Page**: Explicitly hides components section (line ~1581-1584)
- **Settings Management**: `frontend/src/js/app.js` - `loadSettings()`, `setupSettingsListeners()`, `handleProfileUpdate()`, `handlePasswordUpdate()`, `handleDeleteAccount()`, `showDeleteAccountConfirmation()`
  - **Password Modal**: Change password with real-time strength indicator (red/orange/green)
  - **Avatar Upload/Remove**: Profile picture management in `uploads/avatars/`
  - **Delete Account**: Delete account button with confirmation modal (shows warning about permanent deletion)
  - **Delete Account Modal**: Confirmation dialog with warning about what will be deleted (projects, deployments, environment variables, VM, account data)
  - **Account Deletion Flow**: Shows confirmation modal → Calls `DELETE /api/user/account` → Clears localStorage → Redirects to login page
  - **Toast Notifications**: Success/error/info messages for actions
- **Environment Variables Management**: `frontend/src/js/app.js` - `loadEnvVars()`, `saveEnvVars()`, `setupEnvVarsListeners()`
  - **No Project Selector**: Removed dropdown - uses `currentProject.id` exclusively
  - **Current Project Only**: Shows/manages vars for currently selected project only
  - **Import/Export**: Import from .env file, add/edit/delete variables
  - **Location**: Accessible via project sidebar → Environment Variables
- **Environment Variable Detection**: `frontend/src/js/app.js` - `showEnvVarsDetectionDialog()` at line ~1973
  - **Pre-Deploy Detection**: Automatically detects env vars from code when clicking "Deploy All"
  - **Detection Dialog**: Shows 3 options: Import All (auto-saves), Add Manually (navigates to env vars page), No Skip (proceeds)
  - **Auto-Import**: Merges detected vars with existing ones, saves to current project
  - **Integration**: Called in "Deploy All" button handler at line ~1389-1403
  - **API**: Uses `/api/env-vars/detect` endpoint with frontend_url & backend_url params
- **Multi-Repository Detection**: `frontend/src/js/app.js` - In `loadProjects()` function at line ~759
  - **Detection Logic**: Checks `git_url.startsWith('split::')` as most reliable method (works before and after deployment)
  - **Project Type**: Sets `project_type: 'split'` or `'single'` explicitly in project object
  - **Fallback**: Also checks status `'imported_split'` and parent_project_id for compatibility
  - **URL Parsing**: Extracts `frontend_url` and `backend_url` from `split::{frontend}|{backend}` format
- **Deploy Page Logic**: `frontend/src/js/app.js` - `showProjectContent('deploy')` at line ~1190
  - **Key Fix**: Always shows deploy page when clicking project (not configuration or components page)
  - **Project Type Detection**: Double-checks `git_url` format even if `project_type` is set
  - **Multi-Repos**: Shows multi layout (frontend/backend inputs) when `project_type === 'split'`
  - **Single Repos**: Shows single URL input when `project_type === 'single'`
  - **New Deploy**: Shows dropdown only when `currentProject` is null (from "+ New Deploy" button)
  - **Critical Fix**: Navigation between pages now reloads fresh project data to prevent stale state
- **Project Selection**: `frontend/src/js/app.js` - `selectProject(projectId)` at line ~1035
  - **Behavior**: Reloads projects before showing sidebar to ensure fresh data
  - **Initial Page**: Always calls `showProjectContent('deploy')` to show deploy page first
- **Navigation Fix**: `frontend/src/js/app.js` - Project sidebar navigation at line ~1145
  - **Critical Fix**: Project navigation now async reloads fresh data before showing page content
  - **Prevents**: Stale project data causing wrong deploy layout after deployment
  - **Flow**: await loadProjects() → update currentProject → showProjectContent(page)
- **Multi-Repository Deploy Button**: `frontend/src/js/app.js` - "Deploy All" button handler at line ~1348
  - **Critical Fix**: Changed from sequential `deploySingle()` calls to proper `/deploy` with `deploy_type='split'`
  - **Why**: Ensures proper parent/child relationship and uses `run_split_deployment()`
  - **Previous Bug**: Deployed as separate projects instead of linked components

### Frontend UI Components
- **Delete Button CSS**: `frontend/src/css/styles.css` - `.btn-delete` at line ~2109
- **Delete Confirmation Modal CSS**: `frontend/src/css/styles.css` - `.modal-overlay`, `.delete-confirmation-modal` at line ~1244
- **Project Cards**: `frontend/src/js/app.js` - `renderProjects()` at line ~806
- **Project Footer**: `frontend/src/js/app.js` - In `renderProjects()` template at line ~855

## Backend Files

### Core Application
- **Main FastAPI App**: `orchestrator.py` - Entry point, routes, WebSocket handlers
- **Database Models**: `login.py` - User, Deployment, EnvironmentVariable models
- **Database Setup**: `database.py` - Database engine, migrations, session management
- **VM Management**: `vm_manager.py` - OrbStack VM lifecycle management (create, start, stop, delete, exec commands)
- **Process Deployment**: `process_deployment.py` - VM-based process deployment (clones to VM, builds/runs inside VM)
- **Utilities**: `utils.py` - Utility functions (validate_git_url, extract_repo_name)
- **Process Management**: `process_manager.py` - Process lifecycle management (legacy, processes now run directly in VMs)
- **Authentication**: `auth.py` - User authentication, registration, and VM creation on user registration
- **Cloudflare Manager**: `cloudflare_manager.py` - Cloudflare tunnel and DNS management for domain routing

### API Endpoints (orchestrator.py)
- **Health Check**: `GET /health` - Line ~252
- **Deploy**: `POST /deploy` - Line ~574 (handles single & split deployments)
  - **Parameters**: `deploy_type` ('single' or 'split'), `git_url` or `frontend_url`+`backend_url`, optional `project_id`, optional `component_type`
  - **Split Flow**: Line 642-647 - Uses `project_id` as `parent_id` if provided, calls `run_split_deployment()`
  - **Single Flow**: Line 648-680 - Reuses existing deployment if `project_id` provided without `component_type`, or deploys as child component if `component_type` provided
  - **Component Deployment**: Line 667-668 - When `component_type` provided, uses `project_id` as `parent_id` for child deployment
  - **Environment**: Loads user env vars into temp directory as `frontend.env` and `backend.env` (lines 622-636)
- **List Deployments**: `GET /deployments` - Line ~908 (filters out child components with `parent_project_id IS NULL`)
- **Get Project Components**: `GET /projects/{project_id}/components` - Line ~969 (returns frontend/backend children)
- **Delete Project**: `DELETE /projects/{project_id}` - Line ~1204
  - **Cascade Deletion**: Now deletes all child components (containers, images, env vars, DB records)
  - **Split Repo Support**: Stops/removes all frontend/backend containers when deleting parent
- **Import Repository**: `POST /api/import` - Line ~745 (single repo, creates parent with git_url)
- **Import Multi-Repository**: `POST /api/import-split` - Line ~822 (frontend + backend, creates parent with `split::` git_url)
  - **Key Format**: Line 821 - Creates git_url as `split::{frontend_url}|{backend_url}`
  - **Status**: Sets status to `'imported_split'` (line 827)
  - **Naming**: Auto-generates app_name as `{fe_name}-{be_name}` (lines 816-819)
- **Authentication - Login**: `POST /api/auth/login` - Line ~278
  - **Request Format**: JSON body with Pydantic model `UserLogin` (username, password)
  - **NOT form data**: Endpoint expects `Content-Type: application/json`
  - **Request Body**: `{"username": "string", "password": "string"}`
  - **Response**: Returns `{"access_token": "...", "token_type": "bearer", "username": "..."}`
  - **Token Expiry**: 30 minutes (line 299)
  - **Auth**: No authentication required (public endpoint)
- **Authentication - Register**: `POST /api/auth/register` - Line ~358
  - **Request Format**: JSON body with Pydantic model `UserRegister` (username, email, password)
  - **Request Body**: `{"username": "string", "email": "string", "password": "string"}`
  - **Response**: Returns `{"message": "User created successfully"}`
  - **Auth**: No authentication required (public endpoint)
  - **VM Creation**: Automatically creates OrbStack VM for new user (asynchronous, non-blocking)
  - **VM Name**: Format `butler-user-{user_id}` (e.g., "butler-user-1")
  - **VM Setup**: Installs dependencies (git, nodejs, python3, etc.) in VM after creation
  - **Error Handling**: User registration succeeds even if VM creation fails (VM will be created on first deployment)
- **User Profile**: `GET /api/user/profile` - Line ~462 (returns user data including avatar_url)
- **Update Profile**: `PUT /api/user/profile` - Line ~473 (handles avatar upload, password change, profile updates)
  - **Avatar Storage**: Saves to `uploads/avatars/` (NOT `static/avatars/` to prevent deletion on build)
  - **Avatar URL**: Returns `/avatars/{user_id}_{random}.{ext}` format
  - **Avatar Serving**: FastAPI mounts `/avatars` from `uploads/avatars/` directory
- **Delete Account**: `DELETE /api/user/account` - Line ~2078 (deletes user account and all associated data)
  - **Deletion Process**: Stops all processes in user's deployments (inside VM), removes Cloudflare DNS records, deletes project directories, deletes all environment variables, deletes all deployments (including child deployments), deletes the user's OrbStack VM, and finally deletes the user account
  - **VM Deletion**: Checks if VM exists before deletion (even if no deployments reference it), stops VM, then deletes it
  - **Error Handling**: Continues with deletion even if individual steps fail (logs errors but doesn't stop)
  - **Response**: Returns `{"message": "Account deleted successfully"}` on success
  - **Authentication**: Requires Bearer token (`current_user: User = Depends(get_current_user)`)
- **Environment Variables API**: `GET /api/env-vars` - Line ~383 (get vars for current project)
- **Environment Variables API**: `POST /api/env-vars` - Line ~409 (save vars for current project)
- **Environment Variable Detection**: `GET /api/env-vars/detect` - Line ~461
  - **Path**: `/api/env-vars/detect` (full path, no routing conflicts)
  - **Request**: Query parameters (`?frontend_url=...&backend_url=...` or `?git_url=...`)
  - **Parameters**: `frontend_url`, `backend_url`, or `git_url` (for single repo)
  - **Authentication**: Requires Bearer token (`current_user: User = Depends(get_current_user)`)
  - **Functionality**: Clones repos to temp directory, scans code for env var patterns, returns suggestions
  - **Timeout**: 60 seconds per git clone operation
  - **Helper Function**: `_detect_env_from_repo()` - Line ~523
    - **Patterns**: process.env, os.getenv, os.environ, ${VAR}, env()
    - **Config Files**: next.config, .env.example, package.json, settings.py, etc.
    - **Filter**: Ignores common vars (NODE_ENV, PATH, HOME, etc.)
    - **Priority**: Vars from config files get higher priority (10 vs 5)
  - **Response**: `{"suggestions": {"VAR_NAME": {"detected_from": "file", "source": "process.env", "component": "frontend", "priority": 10}}}`
  - **Error Handling**: Returns empty suggestions dict on error (doesn't fail deployment)

### Deployment Logic (process_deployment.py)
- **Main Pipeline**: `run_process_deployment()` - Line ~222 (handles VM-based deployments)
  - **VM-Based**: Gets or creates user's VM, clones repo inside VM, builds/runs inside VM
  - **VM Paths**: Projects stored in `/projects/{project_id}` inside VM
  - **Process Management**: Starts processes in background using `nohup` inside VM
  - **Domain Generation**: Auto-generates domain as `project-name.aayush786.xyz`
  - **Cloudflare Integration**: Automatically configures Cloudflare tunnel after deployment
- **VM Operations**: 
  - **Clone**: `vm_manager.exec_in_vm()` to clone repo inside VM
  - **Build**: `vm_manager.exec_in_vm()` to execute build commands inside VM
  - **Start**: `vm_manager.exec_in_vm()` to start process in background inside VM
  - **Process Tracking**: PID stored in `/tmp/project-{id}.pid`, logs in `/tmp/project-{id}.log`
- **Domain Configuration**: 
  - **Format**: `project-name.aayush786.xyz` (extracted from project name or repo name)
  - **Service URL**: `http://localhost:{port}` (OrbStack forwards VM ports to host)
  - **Cloudflare**: Automatically configures tunnel ingress and DNS records
- **Monorepo Support**: Detects frontend/backend folders, deploys separately with environment variable linking
- **Split Repo Support**: Deploys frontend and backend from separate repos, connects via environment variables
- **Command Auto-Detection**: Detects build/start commands with priority: 1) User-provided, 2) AI analysis results from database, 3) Dockerfile/docker-compose (via dockerfile_parser), 4) File-based detection (package.json, requirements.txt, etc.). AI analysis results take priority over file-based detection when available.
- **URL Validation**: `validate_git_url()` - In `utils.py`
- **Repo Name Extraction**: `extract_repo_name()` - In `utils.py`

### Database Models (login.py)
- **User Model**: Line ~6 - Authentication, profile, tokens
- **Deployment Model**: Line ~22 - Container deployments with parent_project_id, component_type
- **EnvironmentVariable Model**: Line ~53 - User env vars per project

### Database Migrations (database.py)
- **Table Creation**: `create_db_and_tables()` - Line ~14
- **Column Migrations**: Lines ~25-63 - Adds app_name, updated_at, user_id, parent_project_id, component_type, build_command, start_command, port, process_pid, project_dir, vm_name, vm_ip, host_port

## Split Repository Feature

### Database Schema
- **Parent Project**: Deployment with `parent_project_id = None`, `component_type = None`
- **Frontend Component**: Deployment with `parent_project_id = parent_id`, `component_type = 'frontend'`
- **Backend Component**: Deployment with `parent_project_id = parent_id`, `component_type = 'backend'`

### How Multi-Repositories Work (formerly "Split Repos")
- **User-Facing Name**: "Multi-Repository (Frontend + Backend)"
- **Internal Code**: Still uses "split" for API compatibility (deploy_type='split', split:: format, etc.)
1. **Import**: User imports via `/api/import-split` - creates parent with status 'imported_split' and git_url='split::{frontend}|{backend}'
2. **Deploy**: User clicks "Deploy All" - uses `/deploy` with `deploy_type='split'` which calls `run_split_deployment()`
3. **Deploy Process**: `run_split_deployment()` creates/uses parent, then deploys backend then frontend as children
4. **Display**: Dashboard shows only parent projects (`parent_project_id IS NULL` filter)
5. **Details**: Configuration page shows components via `/projects/{id}/components` endpoint
6. **Deletion**: Deleting parent now cascades to all children (containers, images, env vars, DB records)

### Multi-Repository Detection (Critical)
- **Most Reliable**: `git_url.startsWith('split::')` - works before AND after deployment
- **Status Fallback**: `status === 'imported_split'` - only before deployment
- **Database Integrity**: Parent MUST have `parent_project_id = NULL` and `component_type = NULL`
- **Children**: Must have `parent_project_id = parent.id` and `component_type = 'frontend'|'backend'`
- **Import Format**: `/api/import-split` creates git_url = `split::{frontend_url}|{backend_url}` (line 821)
- **Deploy Format**: `run_split_deployment()` uses same format when creating parent (line 1119)

### Deploy Page Behavior
- **New Deploy** (from "+ New Deploy" button): Shows dropdown to choose single/multi, `currentProject` is null
- **Existing Multi-Repository Project**: Shows multi layout (frontend/backend inputs + "Deploy All") without dropdown, shows components section if both deployed
- **Existing Single Project**: Shows single URL input without dropdown
- **Key Fix**: Deploy page is ALWAYS shown when clicking on a project (not configuration or components page)
- **Components Section**: Only shown on deploy page, above "Deploy New Application" card, when both frontend and backend are deployed
- **Critical Bug Fixed**: Multi-repo showing single-repo form after deployment
  - **Root Cause**: Stale `currentProject` object after deployment, missing parent project in database
  - **Solution**: Navigation reloads fresh data, ensure parent has `git_url` in `split::` format

## CSS Class Reference

### Buttons
- `.btn-primary` - Green primary button
- `.btn-secondary` - Gray secondary button  
- `.btn-dark` - Dark blue button (used for "Open Site")
- `.btn-danger` - Red button (delete actions)
- `.btn-delete` - Delete button on project cards (line ~2109)
- `.btn-block` - Full-width button

### Modals
- **All Modal CSS**: `frontend/src/css/styles.css` - Lines ~1217-1566
- **Modal Overlay**: `.modal-overlay` (line ~1245) - Fixed overlay backdrop
- **Modal Content**: `.modal-content` (line ~1230) - Base modal container
- **Enhanced Modal**: `.modal-content.enhanced` (line ~1324) - Wider modal variant

#### Delete Confirmation Dialog
- **JS Function**: `frontend/src/js/app.js` - `showDeleteConfirmation()` at line ~182
- **CSS**: `.delete-confirmation-modal` (line ~1258), `.delete-confirmation-actions` (line ~1286)

#### Split Import Dialog
- **JS Function**: `frontend/src/js/app.js` - `showSplitImportDialog()` at line ~2239
- **CSS Classes**: Lines ~1373-1474
  - `.split-import-modal-center` - Centered header section
  - `.split-import-icon-wrapper` - Icon container
  - `.split-import-repo-info` - Repository details container
  - `.split-import-actions` - Action buttons container

#### Project Name Modal
- **JS Function**: `frontend/src/js/app.js` - `openProjectNameModal()` at line ~1519
- **CSS Classes**: Lines ~1476-1566
  - `.project-name-modal-header` - Header section
  - `.project-name-modal-form-group` - Input form group
  - `.project-name-modal-actions` - Action buttons container
  - `.cancel-name-btn`, `.save-name-btn` - Button styles

#### Project Logs Modal
- **JS Function**: `frontend/src/js/app.js` - `showProjectLogsModal()` at line ~889
- **CSS**: `.logs-modal` (line ~1678), `.modal-header`, `.modal-body`, `.modal-footer`

### Project Cards
- `.project-card` - Individual project card container
- `.project-header` - Card header with icon and status
- `.project-info` - Card body with name and metadata
- `.project-footer` - Footer with action buttons
- `.project-status` - Status badge (RUNNING, IMPORTED, etc.)

## File Structure

```
Devops_Butler/
├── orchestrator.py          # FastAPI main app
├── process_deployment.py    # VM-based deployment logic
├── vm_manager.py            # OrbStack VM management
├── project_analyzer.py      # AI project analysis (Gemini)
├── utils.py                 # Utility functions
├── login.py                 # Database models
├── database.py              # DB setup & migrations
├── auth.py                  # Authentication & user management
├── cloudflare_manager.py    # Cloudflare tunnel & DNS
├── process_manager.py       # Process management (legacy)
├── frontend/
│   ├── src/
│   │   ├── index.html       # Main SPA
│   │   ├── js/
│   │   │   └── app.js       # All frontend logic
│   │   └── css/
│   │       └── styles.css   # All styles
│   └── package.json
├── static/                  # Built frontend (served by FastAPI)
├── uploads/
│   └── avatars/             # User profile pictures (not deleted on build)
└── icons/                   # Application icons (logo.png, devops.png)
```

## Key Concepts

### Project Status Values
- `'running'` - Container is currently running
- `'imported'` - Repository imported but not deployed
- `'imported_split'` - Split repo imported but not deployed
- `'success'` - Deployment succeeded (may be stopped)
- `'failed'` - Deployment failed

### Component Types
- `None` - Standalone or parent project
- `'frontend'` - Frontend component of split repo
- `'backend'` - Backend component of split repo

### Git URL Formats
- Normal: `https://github.com/user/repo.git`
- Split: `split::{frontend_url}|{backend_url}`

## Common Tasks

### Add New API Endpoint
1. Add route in `orchestrator.py`
2. Add authentication if needed: `current_user: User = Depends(get_current_user)`
3. Use database session: `with Session(engine) as session:`

### Modify Frontend Page
1. Edit HTML in `frontend/src/index.html`
2. Edit logic in `frontend/src/js/app.js`
3. Edit styles in `frontend/src/css/styles.css`
4. Run `cd frontend && npm run build` to compile

### Change Database Schema
1. Update model in `login.py`
2. Add migration in `database.py` `create_db_and_tables()` function
3. Server auto-applies on restart

### API Authentication & Request Formats
- **Login/Register**: Expect JSON body (`Content-Type: application/json`), NOT form data
  - Login: `POST /api/auth/login` with `{"username": "...", "password": "..."}`
  - Register: `POST /api/auth/register` with `{"username": "...", "email": "...", "password": "..."}`
- **Authenticated Endpoints**: Most API endpoints require Bearer token in `Authorization` header
  - Format: `Authorization: Bearer {access_token}`
  - Token obtained from login endpoint, valid for 30 minutes
- **Query Parameters**: Some endpoints use query params (e.g., `/api/env-vars/detect?frontend_url=...`)
- **Form Data**: Deployment endpoint (`/deploy`) uses `Form` data, not JSON

### Debugging
- Backend logs: Terminal running `orchestrator.py`
- Frontend console: Browser DevTools
- Database: `deployments.db` SQLite file
- **API Testing**: Use curl with proper Content-Type headers:
  - JSON: `curl -X POST -H "Content-Type: application/json" -d '{"username":"..."}' ...`
  - Auth: `curl -H "Authorization: Bearer {token}" ...`

### Multi-Repository Flow (Complete) - User-facing name for what was "Split Repository"
1. **User imports multi-repo** → `/api/import-split` creates parent with:
   - `git_url = "split::{frontend_url}|{backend_url}"` (line 821)
   - `status = 'imported_split'` (line 827)
   - `parent_project_id = None`, `component_type = None`
   - Returns project_id
2. **User clicks "Deploy All"** → Frontend sends to `/deploy`:
   - `deploy_type = 'split'`, `frontend_url`, `backend_url`, `project_id`
   - Backend receives `project_id` as `parent_id` (line 646)
   - Calls `run_split_deployment(parent_project_id=parent_id)`
3. **Backend deployment** → `run_split_deployment()` at line 1096:
   - Checks if `parent_project_id` is None → creates parent if needed (line 1115)
   - Creates parent with `split::` format git_url (line 1119)
   - Deploys backend first as child (line 1141) with `component_type='backend'`
   - Deploys frontend second as child (line 1148) with `component_type='frontend'`
   - Children link to parent via `parent_project_id`
4. **Individual Frontend/Backend deployment** → User clicks "Deploy Frontend" or "Deploy Backend":
   - Frontend sends to `/deploy`: `deploy_type='single'`, `component_type='frontend'|'backend'`, `project_id=parent`
   - Backend receives `project_id` as parent and `component_type` (line 667-668)
   - Calls `run_deployment_pipeline()` with `parent_project_id` and `component_type` (lines 673-680)
   - Pipeline finds existing child by `parent_project_id + component_type` or creates new child (lines 831-861)
   - Updates existing child if found, otherwise creates new child linked to parent
5. **Frontend displays** → Dashboard loads:
   - `/deployments` returns only parents (`parent_project_id IS NULL`)
   - Multi-repos detected by `git_url.startsWith('split::')`
   - Deploy page shows multi form with pre-filled URLs
   - Config page shows components section with frontend/backend cards
6. **User deletes multi-repo** → `DELETE /projects/{parent_id}`:
   - Stops process inside VM (if process_pid exists)
   - Removes Cloudflare DNS record (if custom_domain exists)
   - Deletes project directory from VM (verifies existence before deletion)
   - Finds all children where `parent_project_id = parent_id`
   - For each child: stops process, removes directory from VM, removes Cloudflare DNS, deletes env vars, deletes DB record
   - Deletes parent's env vars and DB record
   - Then deletes parent
7. **User deletes account** → `DELETE /api/user/account`:
   - Stops all processes in user's deployments (inside VM)
   - Removes all Cloudflare DNS records for user's domains
   - Deletes all project directories inside VM
   - Deletes all project directories on host (legacy deployments)
   - Deletes all environment variables
   - Deletes all deployments (including child deployments)
   - Deletes the user's OrbStack VM
   - Deletes the user account from database
   - Redirects to login page after successful deletion

New (stability guard rails):
--------------------------------
- Deployment state machine and guard:
  - `utils.py`:
    - `ALLOWED_TRANSITIONS`: canonical transitions for statuses (`imported`, `imported_split`, `starting`, `running`, `success`, `failed`)
    - `set_status(deployment, new_status)`: enforces allowed transitions with logging
    - Invariant helpers: `DeploymentError`, `assert_parent_is_split`, `assert_child_component`, `assert_vm_running_fields`, `assert_domain_service_localhost`
- VM adapter:
  - `vm_manager.py`:
    - `class VMError(Exception)`: raised on VM execution failures
    - `async def safe_exec(vm_name, command, ...)`: executes via OrbStack and raises `VMError` when non-zero
- Cloudflare adapter:
  - `cloudflare_manager.py`:
    - `safe_configure_domain(hostname, service_url)`: wraps `ensure_project_hostname` and normalizes errors to `CloudflareError`
- Structured logging:
  - `process_deployment.py`:
    - `log_step(deployment_id, step, message, level=\"INFO\")` for pipeline-style logs
    - Replaced direct `deployment.status = ...` in key paths to `set_status(...)`
- Doctor endpoint:
  - `orchestrator.py`:
    - `GET /debug/deployment/{id}` returns `{ db, vm, cloudflare }` snapshot, including port-open check and basic VM dir presence

